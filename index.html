<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Grid Path Puzzle - Fixed</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.22.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #111827;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #root {
            width: 100%;
            height: 100%;
            overflow: auto;
            -webkit-overflow-scrolling: touch;
        }
        .barrier-cell {
            background: #dc2626 !important;
            border: 2px solid #991b1b !important;
        }
        .barrier-cell::after {
            content: '';
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useRef, useCallback, useEffect } = React;

        // Simple icon components
        const RotateCcw = () => React.createElement('span', null, '🔄');
        const Play = () => React.createElement('span', null, '▶️');
        const Trophy = () => React.createElement('span', null, '🏆');
        const Camera = () => React.createElement('span', null, '📸');
        const Lightbulb = () => React.createElement('span', null, '💡');
        const Undo = () => React.createElement('span', null, '↶');

        const GridPathGame = () => {
            const [difficulty, setDifficulty] = useState('easy');
            const [gameState, setGameState] = useState('menu');
            const [grid, setGrid] = useState([]);
            const [path, setPath] = useState([]);
            const [currentNumber, setCurrentNumber] = useState(1);
            const [score, setScore] = useState(0);
            const [timeElapsed, setTimeElapsed] = useState(0);
            const [gameStartTime, setGameStartTime] = useState(null);
            const [maxNumber, setMaxNumber] = useState(9);
            const [showHint, setShowHint] = useState(false);
            const [backtracks, setBacktracks] = useState(0);
            const [isDragging, setIsDragging] = useState(false);
            const [dragPath, setDragPath] = useState([]);
            const gameRef = useRef(null);
            const canvasRef = useRef(null);
            const gridRef = useRef(null);
            const intervalRef = useRef(null);

            // FIXED: Proper difficulty system with sparse numbers and barriers
            const difficulties = {
                easy: { 
                    size: 4, 
                    maxNumber: 8, // Only 8 numbers instead of 16
                    barriers: 0, 
                    description: "4×4 grid, 8 numbers, no barriers"
                },
                medium: { 
                    size: 5, 
                    maxNumber: 10, // Only 10 numbers instead of 25
                    barriers: 2, 
                    description: "5×5 grid, 10 numbers, 2 barriers"
                },
                hard: { 
                    size: 6, 
                    maxNumber: 12, // Only 12 numbers instead of 36
                    barriers: 4, 
                    description: "6×6 grid, 12 numbers, 4 barriers"
                },
                expert: { 
                    size: 7, 
                    maxNumber: 14, // Only 14 numbers instead of 49
                    barriers: 6, 
                    description: "7×7 grid, 14 numbers, 6 barriers"
                }
            };

            // FIXED: Generate grid with guaranteed solvability
            const generateGrid = useCallback((size, maxNumber, barrierCount) => {
                console.log(`Generating grid: ${size}x${size}, numbers: ${maxNumber}, barriers: ${barrierCount}`);
                
                // Create empty grid
                const newGrid = [];
                for (let i = 0; i < size; i++) {
                    const row = [];
                    for (let j = 0; j < size; j++) {
                        row.push({
                            value: 0,
                            row: i,
                            col: j,
                            visited: false,
                            isBarrier: false,
                            x: j,
                            y: i
                        });
                    }
                    newGrid.push(row);
                }
                
                // Generate a valid path through ALL cells first
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                const usedCells = new Set();
                const pathCells = [];
                
                // Start from a corner
                let currentRow = 0;
                let currentCol = 0;
                
                // Create path through all cells
                pathCells.push({ row: currentRow, col: currentCol });
                usedCells.add(`${currentRow},${currentCol}`);
                
                // Generate path through all remaining cells
                while (pathCells.length < size * size) {
                    const validMoves = [];
                    
                    for (const [dr, dc] of directions) {
                        const newRow = currentRow + dr;
                        const newCol = currentCol + dc;
                        
                        if (newRow >= 0 && newRow < size && 
                            newCol >= 0 && newCol < size && 
                            !usedCells.has(`${newRow},${newCol}`)) {
                            validMoves.push([newRow, newCol]);
                        }
                    }
                    
                    // If no valid moves, try to find a different starting point
                    if (validMoves.length === 0) {
                        // Find an unused cell adjacent to the path
                        let found = false;
                        for (let i = 0; i < size && !found; i++) {
                            for (let j = 0; j < size && !found; j++) {
                                if (!usedCells.has(`${i},${j}`)) {
                                    // Check if this cell is adjacent to any used cell
                                    for (const [dr, dc] of directions) {
                                        const adjRow = i + dr;
                                        const adjCol = j + dc;
                                        if (adjRow >= 0 && adjRow < size && 
                                            adjCol >= 0 && adjCol < size && 
                                            usedCells.has(`${adjRow},${adjCol}`)) {
                                            currentRow = i;
                                            currentCol = j;
                                            pathCells.push({ row: currentRow, col: currentCol });
                                            usedCells.add(`${currentRow},${currentCol}`);
                                            found = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        
                        if (!found) {
                            console.log('Failed to generate complete path, retrying...');
                            return generateGrid(size, maxNumber, barrierCount);
                        }
                    } else {
                        // Choose random valid move
                        const [nextRow, nextCol] = validMoves[Math.floor(Math.random() * validMoves.length)];
                        currentRow = nextRow;
                        currentCol = nextCol;
                        pathCells.push({ row: currentRow, col: currentCol });
                        usedCells.add(`${currentRow},${currentCol}`);
                    }
                }
                
                // Now place numbers on the path at strategic intervals
                const numberInterval = Math.floor(pathCells.length / maxNumber);
                for (let num = 1; num <= maxNumber; num++) {
                    const pathIndex = Math.min((num - 1) * numberInterval, pathCells.length - 1);
                    const cell = pathCells[pathIndex];
                    newGrid[cell.row][cell.col].value = num;
                }
                
                // Add barriers to cells that are NOT in the path
                let barriersPlaced = 0;
                const maxAttempts = 100;
                let attempts = 0;
                
                while (barriersPlaced < barrierCount && attempts < maxAttempts) {
                    const row = Math.floor(Math.random() * size);
                    const col = Math.floor(Math.random() * size);
                    
                    // Only place barriers in cells that don't have numbers and are not in the path
                    if (newGrid[row][col].value === 0 && !newGrid[row][col].isBarrier) {
                        newGrid[row][col].isBarrier = true;
                        barriersPlaced++;
                    }
                    attempts++;
                }
                
                console.log(`Grid generated successfully with ${barriersPlaced} barriers and ${maxNumber} numbers`);
                return newGrid;
            }, []);

            // Get cell from coordinates
            const getCellFromCoords = useCallback((clientX, clientY) => {
                if (!gridRef.current || !grid.length) return null;
                
                const gridRect = gridRef.current.getBoundingClientRect();
                const config = difficulties[difficulty];
                const cellSize = 300 / config.size;
                
                const x = clientX - gridRect.left - 10;
                const y = clientY - gridRect.top - 10;
                
                if (x < 0 || y < 0) return null;
                
                const col = Math.floor(x / (cellSize + 1));
                const row = Math.floor(y / (cellSize + 1));
                
                if (row >= 0 && row < config.size && col >= 0 && col < config.size) {
                    return { row, col };
                }
                
                return null;
            }, [grid, difficulty]);

            // Start new game
            const startGame = useCallback(() => {
                const config = difficulties[difficulty];
                const newGrid = generateGrid(config.size, config.maxNumber, config.barriers);
                setGrid(newGrid);
                setPath([]);
                setCurrentNumber(1);
                setGameState('playing');
                setScore(0);
                setTimeElapsed(0);
                setGameStartTime(Date.now());
                setMaxNumber(config.maxNumber);
                setShowHint(false);
                setBacktracks(0);
                setIsDragging(false);
                setDragPath([]);
            }, [difficulty, generateGrid]);

            // Timer effect
            useEffect(() => {
                if (gameState === 'playing' && gameStartTime) {
                    intervalRef.current = setInterval(() => {
                        setTimeElapsed(Date.now() - gameStartTime);
                    }, 100);
                } else {
                    if (intervalRef.current) {
                        clearInterval(intervalRef.current);
                    }
                }
                
                return () => {
                    if (intervalRef.current) {
                        clearInterval(intervalRef.current);
                    }
                };
            }, [gameState, gameStartTime]);

            // FIXED: Path drawing that goes through ALL cells (numbered and empty)
            const drawPath = useCallback(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const config = difficulties[difficulty];
                const cellSize = 300 / config.size;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const currentPath = isDragging ? dragPath : path;
                
                if (currentPath.length < 2) return;
                
                // Draw clean, thick path
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 10;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.shadowColor = '#ff6b35';
                ctx.shadowBlur = 8;
                
                if (currentPath.length >= 2) {
                    ctx.beginPath();
                    
                    // Start point
                    const start = currentPath[0];
                    const startX = (start.col + 0.5) * (cellSize + 1);
                    const startY = (start.row + 0.5) * (cellSize + 1);
                    ctx.moveTo(startX, startY);
                    
                    // Draw smooth curves between points
                    for (let i = 1; i < currentPath.length; i++) {
                        const current = currentPath[i];
                        const x = (current.col + 0.5) * (cellSize + 1);
                        const y = (current.row + 0.5) * (cellSize + 1);
                        
                        if (i === 1) {
                            ctx.lineTo(x, y);
                        } else {
                            const prev = currentPath[i - 1];
                            const prevX = (prev.col + 0.5) * (cellSize + 1);
                            const prevY = (prev.row + 0.5) * (cellSize + 1);
                            
                            // Create smooth curve
                            const cpX = (prevX + x) / 2;
                            const cpY = (prevY + y) / 2;
                            ctx.quadraticCurveTo(prevX, prevY, cpX, cpY);
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                }
                
                // Draw path points
                ctx.shadowBlur = 0;
                for (let i = 0; i < currentPath.length; i++) {
                    const cell = currentPath[i];
                    const x = (cell.col + 0.5) * (cellSize + 1);
                    const y = (cell.row + 0.5) * (cellSize + 1);
                    
                    // Outer glow
                    ctx.fillStyle = 'rgba(255, 107, 53, 0.3)';
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Inner point
                    ctx.fillStyle = '#ff6b35';
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }, [path, dragPath, isDragging, difficulty]);

            useEffect(() => {
                drawPath();
            }, [drawPath]);

            // FIXED: Handle drag with proper logic for sparse numbers
            const handleDragStart = useCallback((e) => {
                if (gameState !== 'playing') return;
                
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                const cellCoords = getCellFromCoords(clientX, clientY);
                if (!cellCoords) return;
                
                const { row, col } = cellCoords;
                const cell = grid[row][col];
                
                // Can't start on barriers
                if (cell.isBarrier) return;
                
                if (cell.value === currentNumber) {
                    setIsDragging(true);
                    setDragPath([{ row, col, value: cell.value }]);
                } else if (cell.value > 0) {
                    setBacktracks(prev => prev + 1);
                }
            }, [gameState, grid, currentNumber, getCellFromCoords]);

            const handleDragMove = useCallback((e) => {
                if (gameState !== 'playing') return;
                
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                const cellCoords = getCellFromCoords(clientX, clientY);
                if (!cellCoords) return;
                
                const { row, col } = cellCoords;
                const cell = grid[row][col];
                
                // Can't move to barriers
                if (cell.isBarrier) return;
                
                if (!isDragging) {
                    if (cell.value === currentNumber) {
                        setIsDragging(true);
                        setDragPath([{ row, col, value: cell.value }]);
                    }
                    return;
                }
                
                if (dragPath.length === 0) return;
                
                const lastCell = dragPath[dragPath.length - 1];
                
                if (row === lastCell.row && col === lastCell.col) return;
                
                const existingIndex = dragPath.findIndex(p => p.row === row && p.col === col);
                if (existingIndex >= 0) {
                    setDragPath(prev => prev.slice(0, existingIndex + 1));
                    return;
                }
                
                const rowDiff = Math.abs(row - lastCell.row);
                const colDiff = Math.abs(col - lastCell.col);
                
                if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) {
                    // FIXED: Allow moving to ANY empty cell or the next numbered cell
                    const expectedNextNumber = currentNumber + dragPath.filter(c => c.value > 0).length;
                    
                    if ((cell.value === 0 || cell.value === expectedNextNumber) && !cell.visited) {
                        setDragPath(prev => [...prev, { row, col, value: cell.value }]);
                    }
                }
            }, [isDragging, gameState, grid, dragPath, currentNumber, getCellFromCoords]);

            const handleDragEnd = useCallback((e) => {
                if (!isDragging) return;
                
                e.preventDefault();
                
                setTimeout(() => {
                    if (dragPath.length > 0) {
                        let newGrid = [...grid];
                        let newPath = [...path];
                        let newCurrentNumber = currentNumber;
                        
                        // FIXED: Process the path, advancing number only when we hit a numbered cell
                        for (const dragCell of dragPath) {
                            if (dragCell.value === newCurrentNumber) {
                                newGrid[dragCell.row][dragCell.col] = { ...newGrid[dragCell.row][dragCell.col], visited: true };
                                newPath.push(dragCell);
                                newCurrentNumber++;
                            } else if (dragCell.value === 0) {
                                // Empty cell - just mark as visited but don't advance number
                                newGrid[dragCell.row][dragCell.col] = { ...newGrid[dragCell.row][dragCell.col], visited: true };
                                newPath.push(dragCell);
                            }
                        }
                        
                        setGrid(newGrid);
                        setPath(newPath);
                        setCurrentNumber(newCurrentNumber);
                        
                        const newScore = newPath.length * difficulties[difficulty].size * 10 - backtracks * 5;
                        setScore(Math.max(0, newScore));
                        
                        // FIXED: Check if ALL cells (including empty ones) are visited
                        const config = difficulties[difficulty];
                        const totalCells = config.size * config.size;
                        const visitedCells = newGrid.flat().filter(cell => cell.visited && !cell.isBarrier).length;
                        const barrierCells = newGrid.flat().filter(cell => cell.isBarrier).length;
                        const requiredVisitedCells = totalCells - barrierCells;
                        
                        if (visitedCells === requiredVisitedCells && newCurrentNumber - 1 === maxNumber) {
                            setGameState('completed');
                            if (intervalRef.current) {
                                clearInterval(intervalRef.current);
                            }
                        }
                    }
                    
                    setIsDragging(false);
                    setDragPath([]);
                }, 100);
            }, [isDragging, dragPath, grid, path, currentNumber, backtracks, difficulty, maxNumber]);

            const undoMove = () => {
                if (path.length === 0 || gameState !== 'playing') return;
                
                const lastMove = path[path.length - 1];
                const newGrid = [...grid];
                newGrid[lastMove.row][lastMove.col] = { 
                    ...newGrid[lastMove.row][lastMove.col], 
                    visited: false 
                };
                
                setGrid(newGrid);
                setPath(path.slice(0, -1));
                
                // FIXED: Only decrease currentNumber if we're undoing a numbered cell
                if (lastMove.value > 0) {
                    setCurrentNumber(currentNumber - 1);
                }
                
                setBacktracks(prev => prev + 1);
                
                const newScore = Math.max(0, (path.length - 1) * difficulties[difficulty].size * 10 - backtracks * 5);
                setScore(newScore);
            };

            const resetGame = () => {
                setGameState('menu');
                setGrid([]);
                setPath([]);
                setCurrentNumber(1);
                setScore(0);
                setTimeElapsed(0);
                setGameStartTime(null);
                setBacktracks(0);
                setIsDragging(false);
                setDragPath([]);
            };

            const takeScreenshot = async () => {
                if (!gameRef.current) return;
                
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = 400;
                    canvas.height = 600;
                    
                    ctx.fillStyle = '#1f2937';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Grid Path Puzzle', canvas.width/2, 40);
                    
                    ctx.font = '18px Arial';
                    ctx.fillText(`Score: ${score}`, canvas.width/2, 80);
                    ctx.fillText(`Time: ${(timeElapsed/1000).toFixed(1)}s`, canvas.width/2, 110);
                    ctx.fillText(`Difficulty: ${difficulty.toUpperCase()}`, canvas.width/2, 140);
                    ctx.fillText(`Path: ${path.length} | Backtracks: ${backtracks}`, canvas.width/2, 170);
                    
                    canvas.toBlob((blob) => {
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `grid-puzzle-score-${score}-backtracks-${backtracks}.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    });
                } catch (error) {
                    console.error('Screenshot failed:', error);
                }
            };

            const formatTime = (ms) => {
                return (ms / 1000).toFixed(1) + 's';
            };

            if (gameState === 'menu') {
                return React.createElement('div', { 
                    ref: gameRef, 
                    className: "max-w-md mx-auto p-6 bg-gray-900 text-white rounded-xl shadow-2xl" 
                },
                    React.createElement('div', { className: "text-center mb-8" },
                        React.createElement('h1', { className: "text-3xl font-bold mb-2 text-orange-400" }, "Grid Path Puzzle"),
                        React.createElement('p', { className: "text-gray-300" }, "Connect numbers 1→2→3... through ALL cells"),
                        React.createElement('p', { className: "text-gray-400 text-sm mt-2" }, "Find a path that visits every cell"),
                        React.createElement('div', { className: "flex items-center justify-center gap-2 mt-3 text-orange-300" },
                            React.createElement('div', { className: "w-4 h-4 bg-orange-500 rounded-full" }),
                            React.createElement('div', { className: "text-sm" }, "Guaranteed solvable • Navigate barriers • Visit all cells")
                        )
                    ),
                    
                    React.createElement('div', { className: "mb-6" },
                        React.createElement('label', { className: "block text-sm font-medium mb-3 text-gray-300" }, "Choose Difficulty:"),
                        React.createElement('div', { className: "grid grid-cols-2 gap-2" },
                            Object.entries(difficulties).map(([level, config]) =>
                                React.createElement('button', {
                                    key: level,
                                    onClick: () => setDifficulty(level),
                                    className: `p-3 rounded-lg text-center transition-colors ${
                                        difficulty === level 
                                            ? 'bg-orange-600 text-white' 
                                            : 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                                    }`
                                },
                                    React.createElement('div', { className: "font-medium capitalize" }, level),
                                    React.createElement('div', { className: "text-xs" }, `${config.size}×${config.size} grid`),
                                    React.createElement('div', { className: "text-xs" }, config.description)
                                )
                            )
                        )
                    ),
                    
                    React.createElement('button', {
                        onClick: startGame,
                        className: "w-full bg-green-600 hover:bg-green-700 text-white font-medium py-4 px-6 rounded-lg transition-colors flex items-center justify-center gap-2"
                    },
                        React.createElement(Play),
                        "Start Game"
                    )
                );
            }

            const config = difficulties[difficulty];
            const gridSize = config.size;
            const cellSize = Math.floor(300 / gridSize);

            return React.createElement('div', { 
                ref: gameRef, 
                className: "max-w-md mx-auto p-4 bg-gray-900 text-white rounded-xl shadow-2xl" 
            },
                // Header
                React.createElement('div', { className: "text-center mb-4" },
                    React.createElement('div', { className: "flex justify-between items-center mb-2" },
                        React.createElement('div', { className: "flex gap-2" },
                            React.createElement('button', {
                                onClick: undoMove,
                                disabled: path.length === 0,
                                className: "bg-yellow-600 hover:bg-yellow-700 disabled:bg-gray-700 disabled:text-gray-500 p-2 rounded-lg transition-colors"
                            }, React.createElement(Undo)),
                            React.createElement('button', {
                                onClick: () => setShowHint(!showHint),
                                className: `p-2 rounded-lg transition-colors ${showHint ? 'bg-blue-500' : 'bg-blue-600 hover:bg-blue-700'}`
                            }, React.createElement(Lightbulb))
                        ),
                        
                        React.createElement('div', { className: "text-center" },
                            React.createElement('div', { className: "text-lg font-bold text-orange-400" }, `Next: ${currentNumber}`),
                            React.createElement('div', { className: "text-xs text-gray-400" }, difficulty.toUpperCase())
                        ),
                        
                        React.createElement('div', { className: "flex gap-2" },
                            React.createElement('button', {
                                onClick: takeScreenshot,
                                className: "bg-purple-600 hover:bg-purple-700 p-2 rounded-lg transition-colors"
                            }, React.createElement(Camera)),
                            React.createElement('button', {
                                onClick: resetGame,
                                className: "bg-gray-700 hover:bg-gray-600 p-2 rounded-lg transition-colors"
                            }, React.createElement(RotateCcw))
                        )
                    ),
                    
                    React.createElement('div', { className: "flex justify-between text-sm text-gray-300" },
                        React.createElement('span', null, `Score: ${score}`),
                        React.createElement('span', null, `Backtracks: ${backtracks}`),
                        React.createElement('span', null, `Time: ${formatTime(timeElapsed)}`)
                    )
                ),

                // Game Grid
                React.createElement('div', { className: "flex justify-center mb-4" },
                    React.createElement('div', {
                        ref: gridRef,
                        className: "relative bg-gray-100 rounded-lg p-2 select-none",
                        style: { width: '320px', height: '320px' },
                        onMouseDown: handleDragStart,
                        onMouseMove: handleDragMove,
                        onMouseUp: handleDragEnd,
                        onTouchStart: handleDragStart,
                        onTouchMove: handleDragMove,
                        onTouchEnd: handleDragEnd
                    },
                        // Grid
                        React.createElement('div', {
                            className: "absolute inset-2 grid gap-0.5",
                            style: {
                                gridTemplateColumns: `repeat(${gridSize}, ${cellSize}px)`,
                                gridTemplateRows: `repeat(${gridSize}, ${cellSize}px)`
                            }
                        },
                            grid.map((row, rowIndex) =>
                                row.map((cell, colIndex) =>
                                    React.createElement('div', {
                                        key: `${rowIndex}-${colIndex}`,
                                        className: `flex items-center justify-center rounded transition-all ${
                                            cell.isBarrier
                                                ? 'barrier-cell'
                                                : cell.visited 
                                                ? 'bg-orange-200' 
                                                : cell.value === currentNumber && showHint
                                                ? 'bg-yellow-300 animate-pulse'
                                                : 'bg-white'
                                        }`,
                                        style: {
                                            width: `${cellSize}px`,
                                            height: `${cellSize}px`
                                        }
                                    },
                                        !cell.isBarrier && cell.value > 0 && React.createElement('div', {
                                            className: `w-6 h-6 rounded-full flex items-center justify-center text-sm font-bold ${
                                                cell.visited ? 'bg-orange-500 text-white' : 'bg-gray-700 text-white'
                                            }`,
                                            style: { fontSize: cellSize > 40 ? '14px' : '12px' }
                                        }, cell.value)
                                    )
                                )
                            )
                        ),
                        // Canvas for drawing path (behind numbers)
                        React.createElement('canvas', {
                            ref: canvasRef,
                            width: 300,
                            height: 300,
                            className: "absolute top-2 left-2 pointer-events-none",
                            style: { width: '300px', height: '300px', zIndex: 1 }
                        })
                    )
                ),

                // Completion message
                gameState === 'completed' && React.createElement('div', {
                    className: "bg-green-800 border border-green-600 p-4 rounded-lg text-center mb-4"
                },
                    React.createElement(Trophy, { className: "mx-auto mb-2 text-yellow-400", style: { fontSize: '32px' } }),
                    React.createElement('div', { className: "text-lg font-bold text-green-300 mb-1" }, "Puzzle Completed!"),
                    React.createElement('div', { className: "text-sm text-green-400" }, `Final Score: ${score}`),
                    React.createElement('div', { className: "text-sm text-green-400" }, `Time: ${formatTime(timeElapsed)}`),
                    React.createElement('div', { className: "text-sm text-green-400" }, `Backtracks: ${backtracks}`),
                    React.createElement('div', { className: "mt-3 space-x-2" },
                        React.createElement('button', {
                            onClick: takeScreenshot,
                            className: "bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded text-sm transition-colors"
                        }, "📸 Save Score"),
                        React.createElement('button', {
                            onClick: startGame,
                            className: "bg-orange-600 hover:bg-orange-700 text-white px-4 py-2 rounded text-sm transition-colors"
                        }, "Play Again")
                    )
                ),

                // How to Play
                React.createElement('div', { className: "text-center mt-4" },
                    React.createElement('div', { className: "text-xs text-gray-500" },
                        "Connect numbers 1→2→3... • Path through ALL cells • Navigate around barriers 🚫"
                    )
                )
            );
        };

        ReactDOM.render(React.createElement(GridPathGame), document.getElementById('root'));
    </script>
</body>
</html>
